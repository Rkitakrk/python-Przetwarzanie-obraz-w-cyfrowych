{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 1,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "obraz nr 1 size 107314200\n",
      "obiekty przed segmentacja zajmuja 12.798132027262001% obrazu\n",
      "srodek ciezkosci obiektow zajduje sie w pikselu 3297, 2692\n",
      "ilosc monet 26\n",
      "liczba nominalow od sortowana od najwyzszej wartosci:\n",
      "1  2  3  2  4  4  0  5  5\n",
      "suma nominalow to: 14.35\n",
      "obiekty po segmentacji zajmuja 4.0303510625807215% calego obrazu\n",
      "\n",
      "\n",
      "obraz nr 2 size 107314200\n",
      "obiekty przed segmentacja zajmuja 14.040490447676076% obrazu\n",
      "srodek ciezkosci obiektow zajduje sie w pikselu 3507, 2789\n",
      "ilosc monet 28\n",
      "liczba nominalow od sortowana od najwyzszej wartosci:\n",
      "1  3  3  3  4  5  1  4  4\n",
      "suma nominalow to: 16.97\n",
      "obiekty po segmentacji zajmuja 4.513421336598512% calego obrazu\n",
      "\n",
      "\n",
      "obraz nr 3 size 107314200\n",
      "obiekty przed segmentacja zajmuja 14.558001643771282% obrazu\n",
      "srodek ciezkosci obiektow zajduje sie w pikselu 3673, 2443\n",
      "ilosc monet 29\n",
      "liczba nominalow od sortowana od najwyzszej wartosci:\n",
      "2  2  2  4  5  5  2  3  4\n",
      "suma nominalow to: 19.70\n",
      "obiekty po segmentacji zajmuja 4.709471812677166% calego obrazu\n",
      "\n",
      "\n",
      "obraz nr 4 size 107314200\n",
      "obiekty przed segmentacja zajmuja 14.651224162319618% obrazu\n",
      "srodek ciezkosci obiektow zajduje sie w pikselu 3456, 2375\n",
      "ilosc monet 31\n",
      "liczba nominalow od sortowana od najwyzszej wartosci:\n",
      "0  1  2  4  4  5  2  9  4\n",
      "suma nominalow to: 7.62\n",
      "obiekty po segmentacji zajmuja 4.349393649675439% calego obrazu\n",
      "\n",
      "\n",
      "obraz nr 5 size 107314200\n",
      "obiekty przed segmentacja zajmuja 15.407809031796353% obrazu\n",
      "srodek ciezkosci obiektow zajduje sie w pikselu 3324, 2553\n",
      "ilosc monet 33\n",
      "liczba nominalow od sortowana od najwyzszej wartosci:\n",
      "0  1  2  4  6  6  4  6  4\n",
      "suma nominalow to: 8.16\n",
      "obiekty po segmentacji zajmuja 4.648750118809999% calego obrazu\n",
      "\n",
      "\n",
      "obraz nr 6 size 107314200\n",
      "obiekty przed segmentacja zajmuja 12.705904717176292% obrazu\n",
      "srodek ciezkosci obiektow zajduje sie w pikselu 3476, 2657\n",
      "ilosc monet 26\n",
      "liczba nominalow od sortowana od najwyzszej wartosci:\n",
      "0  0  2  4  5  5  2  8  0\n",
      "suma nominalow to: 5.76\n",
      "obiekty po segmentacji zajmuja 3.8309739065286794% calego obrazu\n",
      "\n",
      "\n",
      "obraz nr 7 size 107314200\n",
      "obiekty przed segmentacja zajmuja 11.083558373449181% obrazu\n",
      "srodek ciezkosci obiektow zajduje sie w pikselu 3463, 2560\n",
      "ilosc monet 24\n",
      "liczba nominalow od sortowana od najwyzszej wartosci:\n",
      "0  0  0  4  4  5  3  8  0\n",
      "suma nominalow to: 3.61\n",
      "obiekty po segmentacji zajmuja 3.2598332746272165% calego obrazu\n",
      "\n",
      "\n",
      "obraz nr 8 size 107314200\n",
      "obiekty przed segmentacja zajmuja 10.448450438059455% obrazu\n",
      "srodek ciezkosci obiektow zajduje sie w pikselu 3429, 2725\n",
      "ilosc monet 20\n",
      "liczba nominalow od sortowana od najwyzszej wartosci:\n",
      "0  0  3  4  3  2  2  6  0\n",
      "suma nominalow to: 6.02\n",
      "obiekty po segmentacji zajmuja 3.345038214886753% calego obrazu\n",
      "\n",
      "\n",
      "obraz nr 9 size 107314200\n",
      "obiekty przed segmentacja zajmuja 8.606906634909453% obrazu\n",
      "srodek ciezkosci obiektow zajduje sie w pikselu 3341, 2537\n",
      "ilosc monet 17\n",
      "liczba nominalow od sortowana od najwyzszej wartosci:\n",
      "0  2  0  3  2  1  2  7  0\n",
      "suma nominalow to: 6.24\n",
      "obiekty po segmentacji zajmuja 2.6345041010416144% calego obrazu\n",
      "\n",
      "\n",
      "obraz nr 10 size 107314200\n",
      "obiekty przed segmentacja zajmuja 10.009946493567487% obrazu\n",
      "srodek ciezkosci obiektow zajduje sie w pikselu 3172, 2645\n",
      "ilosc monet 20\n",
      "liczba nominalow od sortowana od najwyzszej wartosci:\n",
      "1  1  0  3  4  2  2  7  0\n",
      "suma nominalow to: 9.74\n",
      "obiekty po segmentacji zajmuja 3.095341529825503% calego obrazu\n",
      "\n",
      "\n",
      "obraz nr 11 size 107314200\n",
      "obiekty przed segmentacja zajmuja 11.774839676389517% obrazu\n",
      "srodek ciezkosci obiektow zajduje sie w pikselu 3083, 2738\n",
      "ilosc monet 23\n",
      "liczba nominalow od sortowana od najwyzszej wartosci:\n",
      "1  0  2  4  5  1  3  7  0\n",
      "suma nominalow to: 10.39\n",
      "obiekty po segmentacji zajmuja 3.8216564070738075% calego obrazu\n",
      "\n",
      "\n",
      "obraz nr 12 size 107314200\n",
      "obiekty przed segmentacja zajmuja 13.244332064162991% obrazu\n",
      "srodek ciezkosci obiektow zajduje sie w pikselu 2802, 2405\n",
      "ilosc monet 25\n",
      "liczba nominalow od sortowana od najwyzszej wartosci:\n",
      "1  1  3  4  6  1  2  7  0\n",
      "suma nominalow to: 13.54\n",
      "obiekty po segmentacji zajmuja 4.408049447323839% calego obrazu\n",
      "\n",
      "\n",
      "obraz nr 13 size 107314200\n",
      "obiekty przed segmentacja zajmuja 16.024692911096576% obrazu\n",
      "srodek ciezkosci obiektow zajduje sie w pikselu 3197, 2626\n",
      "ilosc monet 33\n",
      "liczba nominalow od sortowana od najwyzszej wartosci:\n",
      "1  1  3  4  11  4  2  2  5\n",
      "suma nominalow to: 14.79\n",
      "obiekty po segmentacji zajmuja 5.105419413274292% calego obrazu\n",
      "\n",
      "\n",
      "obraz nr 14 size 107314200\n",
      "obiekty przed segmentacja zajmuja 16.19066349094528% obrazu\n",
      "srodek ciezkosci obiektow zajduje sie w pikselu 3485, 2599\n",
      "ilosc monet 33\n",
      "liczba nominalow od sortowana od najwyzszej wartosci:\n",
      "1  1  3  4  8  6  2  4  4\n",
      "suma nominalow to: 14.42\n",
      "obiekty po segmentacji zajmuja 5.0553319132044034% calego obrazu\n",
      "\n",
      "\n",
      "obraz nr 15 size 107314200\n",
      "obiekty przed segmentacja zajmuja 17.20992748396764% obrazu\n",
      "srodek ciezkosci obiektow zajduje sie w pikselu 3623, 2517\n",
      "ilosc monet 35\n",
      "liczba nominalow od sortowana od najwyzszej wartosci:\n",
      "1  2  3  4  4  5  4  6  6\n",
      "suma nominalow to: 15.68\n",
      "obiekty po segmentacji zajmuja 5.334336928384128% calego obrazu\n",
      "\n",
      "\n",
      "skonczylem\n"
     ]
    }
   ],
   "source": [
    "import cv2\n",
    "import skimage\n",
    "from skimage import morphology\n",
    "from math import *\n",
    "from skimage import io, color, img_as_ubyte\n",
    "i = 1\n",
    "path = './zdj/'\n",
    "##objetosci monet uzyskalem po zastosowaniu algorytmu do zdjec kalibracyjnych, na ktorych byla tylko jedna moneta\n",
    "objMonetWzorcowych=[(5, 120672), (2, 90169), (1, 103360), (0.5, 71826), (0.2, 50099), (0.1, 30330), (0.05, 57423), (0.02, 39650), (0.01, 22815)]\n",
    "plik = open('wlasnosci.txt', 'w')\n",
    "def segmentacja(obraz):\n",
    "     \n",
    "    objetoscObiektow = []\n",
    "    srodekObiektowX = []\n",
    "    srodekObiektowY = []\n",
    "    liczbaPuktowObiektow = []\n",
    "    j = 255\n",
    "    k = 0\n",
    "    img = obraz.copy()\n",
    "    z1 = 1\n",
    "    z2 = 100   \n",
    "    srodekY = 0\n",
    "    srodekX = 0\n",
    "    liczbaPuktow = 0\n",
    "    maxX = []\n",
    "    minX = []\n",
    "    maxY = []\n",
    "    minY = []\n",
    "    for x in range(len(img)):\n",
    "        for y in range(len(img[x])):\n",
    "            if img.item(x,y)==255:\n",
    "                def taksWarunek():\n",
    "                    nonlocal k\n",
    "                    nonlocal srodekObiektowY\n",
    "                    nonlocal srodekObiektowX\n",
    "                    nonlocal liczbaPuktowObiektow\n",
    "                    nonlocal objetoscObiektow\n",
    "                    nonlocal maxY\n",
    "                    nonlocal maxX\n",
    "                    nonlocal minX\n",
    "                    nonlocal minY\n",
    "                    for n in range(x-z1, x+z1, 1):\n",
    "                        for m in range(y-z1, y+z2, 1):\n",
    "                            ##sprawdzam czy w otoczeniu punktu jasnego juz sa inne obiekty, jesli tak przypisuje punkt do pierwszego napotkanego obiektu.\n",
    "                            ##mam pewnosc, ze w otoczeniu nie ma innych obiektow niz szukamy, gdyz zmniejszylem w tym celu wszystkie obiekty\n",
    "                            if img.item(n, m) != 0 and img.item(n, m) != 255:\n",
    "                                img.itemset((x, y), (img.item(n, m)))\n",
    "                                l = int(img.item(n, m))\n",
    "                                objetoscObiektow[(l-1)] += 1\n",
    "                                srodekObiektowX[l-1] += x\n",
    "                                srodekObiektowY[l-1] += y\n",
    "                                liczbaPuktowObiektow[l-1] += 1\n",
    "                                if maxX[l-1] < x:\n",
    "                                    maxX[l-1] = x\n",
    "                                if minX[l-1] > x:\n",
    "                                    minX[l-1] = x\n",
    "                                if maxY[l-1] < y:\n",
    "                                    maxY[l-1] = y\n",
    "                                if minY[l-1] > y:\n",
    "                                    minY[l-1] = y\n",
    "                                return\n",
    "                    maxY.append(y)\n",
    "                    maxX.append(x)\n",
    "                    minY.append(y)\n",
    "                    minX.append(x)\n",
    "                    objetoscObiektow.append(1)\n",
    "                    srodekObiektowX.append(x)\n",
    "                    srodekObiektowY.append(y)\n",
    "                    liczbaPuktowObiektow.append(1)\n",
    "                    k += 1\n",
    "                    img.itemset((x, y), k)\n",
    "                    \n",
    "                srodekX+=x\n",
    "                srodekY+=y\n",
    "                liczbaPuktow+=1\n",
    "                taksWarunek()\n",
    "                \n",
    "    srodekCiezkosciX = int(srodekX/liczbaPuktow)\n",
    "    srodekCiezkosciY = int(srodekY/liczbaPuktow)\n",
    "    \n",
    "    \n",
    "    print('srodek ciezkosci obiektow zajduje sie w pikselu ' + str(srodekCiezkosciX) + ', ' + str(srodekCiezkosciY))\n",
    "    plik.write('srodek ciezkosci obiektow zajduje sie w pikselu ' + str(srodekCiezkosciX) + ', ' + str(srodekCiezkosciY) + '\\n\\n')\n",
    "\n",
    "    srodekCiezkosciObiektowX = []\n",
    "    srodekCiezkosciObiektowY = []\n",
    "    \n",
    "    dOdSrodka = []\n",
    "    for nn in range(len(srodekObiektowX)):\n",
    "        srodekCiezkosciObiektowX.append(int(srodekObiektowX[nn]/liczbaPuktowObiektow[nn]))\n",
    "        srodekCiezkosciObiektowY.append(int(srodekObiektowY[nn]/liczbaPuktowObiektow[nn]))\n",
    "    for x in range(k):\n",
    "        dOdSrodka.append(0)\n",
    "    for x in range(len(img)):\n",
    "        for y in range(len(img[x])):\n",
    "            if img.item(x, y) <= k and img.item(x, y) > 0:\n",
    "                zzz = int(img.item(x, y))\n",
    "                dOdSrodka[zzz - 1] += (abs((x - srodekCiezkosciObiektowX[zzz - 1]))**2 + abs((y - srodekCiezkosciObiektowY[zzz - 1]))**2)       \n",
    "    blairMianownik = []\n",
    "    blair = []\n",
    "\n",
    "    \n",
    "    for nn in range(len(srodekObiektowX)):\n",
    "        plik.write('srodek ciezkosci obiektu ' + str(nn) + ' to ' + str(srodekCiezkosciObiektowX[nn]) + ', ' + str(srodekCiezkosciObiektowY[nn]) + '\\n')\n",
    "        \n",
    "        wysX = maxX[nn] - minX[nn]\n",
    "        wysY = maxY[nn] - minY[nn]\n",
    "        feret = float(wysX/wysY)\n",
    "        plik.write('wspolczynnik fereta wynosi %.4f\\n' % (feret))\n",
    "        blairMianownik.append(sqrt(2*3.14*dOdSrodka[nn]))\n",
    "        blair.append(liczbaPuktowObiektow[nn]/blairMianownik[nn])\n",
    "        plik.write('wspolczynnik Blaira-Blissa wynosi %.4f\\n\\n' % (blair[nn]))\n",
    "    cv2.imwrite('./bin/segment' + str(i) + '.jpg', img)\n",
    "    \n",
    "    print('ilosc monet ' + str(k))\n",
    "    plik.write('\\nilosc monet' + str(k) + '\\n')\n",
    "    listaNominalow = [0, 0, 0, 0, 0, 0, 0, 0, 0]\n",
    "    sumaObjOb=0\n",
    "    for v in objetoscObiektow:\n",
    "        q = 200000\n",
    "        q1 = 0\n",
    "        bc = 0\n",
    "        sumaObjOb+=v\n",
    "        for bx in range(len(objMonetWzorcowych)):\n",
    "            if q > (abs(objMonetWzorcowych[bx][1] - v)):\n",
    "                q = abs(objMonetWzorcowych[bx][1] - v)\n",
    "                q1 = objMonetWzorcowych[bx][0]\n",
    "                bc=bx\n",
    "        listaNominalow[bc] += 1\n",
    "        #print(str(v) + '  ' + str(objMonetWzorcowych[bc][0]))\n",
    "    print('liczba nominalow od sortowana od najwyzszej wartosci:')\n",
    "    plik.write('liczba nominalow od sortowana od najwyzszej wartosci:' + '\\n')\n",
    "    print(str(listaNominalow[0]) + '  ' + str(listaNominalow[1]) + '  ' + str(listaNominalow[2]) + '  ' + str(listaNominalow[3]) + '  ' + str(listaNominalow[4]) + '  ' + str(listaNominalow[5]) + '  ' + str(listaNominalow[6]) + '  ' + str(listaNominalow[7]) + '  ' + str(listaNominalow[8]))                                                                                                                        \n",
    "    plik.write(str(listaNominalow[0]) + '  ' + str(listaNominalow[1]) + '  ' + str(listaNominalow[2]) + '  ' + str(listaNominalow[3]) + '  ' + str(listaNominalow[4]) + '  ' + str(listaNominalow[5]) + '  ' + str(listaNominalow[6]) + '  ' + str(listaNominalow[7]) + '  ' + str(listaNominalow[8]) + '\\n')                                                                                                                        \n",
    "    sumaNominalow = 0\n",
    "    for bb in range(len(listaNominalow)):\n",
    "        sumaNominalow += listaNominalow[bb]*objMonetWzorcowych[bb][0]\n",
    "    print('suma nominalow to: %.2f' % (sumaNominalow))\n",
    "    plik.write('suma nominalow to: %.2f \\n' % (sumaNominalow) )\n",
    "    procentobrazu = (sumaObjOb/img.size)*100\n",
    "    print('obiekty po segmentacji zajmuja ' + str(procentobrazu) + '% calego obrazu\\n' + '\\n')     \n",
    "    plik.write('obiekty po segmentacji zajmuja ' + str(procentobrazu) + '% calego obrazu\\n' + '\\n')  \n",
    "    return k\n",
    "\n",
    "while (i <= 15):\n",
    "    im = io.imread(path + str(i) + '.jpg')\n",
    "   \n",
    "   \n",
    "    th = 210\n",
    "    bim = cv2.cvtColor(im, cv2.COLOR_RGB2GRAY)\n",
    "    print('obraz nr ' + str(i)+' size ' + str(im.size))\n",
    "    plik.write('\\nobraz nr ' + str(i)+' size ' + str(im.size) + '\\n' + '\\n')\n",
    "    th, bim = cv2.threshold(bim, thresh=th, maxval=255, type=cv2.THRESH_BINARY_INV)\n",
    "    import numpy as np\n",
    "\n",
    "    kernel = np.ones((3, 3), np.uint8)\n",
    "\n",
    "    bim = cv2.morphologyEx(bim, op=cv2.MORPH_CLOSE, kernel=kernel, iterations=5)\n",
    "    bim = cv2.morphologyEx(bim, op=cv2.MORPH_OPEN, kernel=kernel, iterations=5)\n",
    "    xcc=0\n",
    "    for x in range(len(bim)):\n",
    "        for y in range(len(bim[x])):\n",
    "            if (bim.item(x, y) == 255):\n",
    "                xcc += 1\n",
    "    xcc=((xcc/bim.size)*100)\n",
    "    print('obiekty przed segmentacja zajmuja ' + str(xcc) + '% obrazu')\n",
    "    plik.write('obiekty przed segmentacja zajmuja ' + str(xcc) + '% obrazu' + '\\n')\n",
    "    bim = cv2.distanceTransform(bim, distanceType=cv2.DIST_L2, maskSize=cv2.DIST_MASK_PRECISE)\n",
    "\n",
    "    bim = cv2.morphologyEx(bim, op=cv2.MORPH_ERODE, kernel=kernel, iterations=80)\n",
    "    th = 60\n",
    "    th, bim = cv2.threshold(bim, thresh=th, maxval=255, type=cv2.THRESH_BINARY)\n",
    "    bim = cv2.morphologyEx(bim, op=cv2.MORPH_DILATE, kernel=kernel, iterations=50)\n",
    "    cv2.imwrite('./bin/plik' + str(i) + '.jpg', bim)\n",
    "    hehe = segmentacja(bim)\n",
    "    #print(str(hehe))\n",
    "    i += 1\n",
    "plik.close()\n",
    "print('skonczylem')\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.7.1"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
